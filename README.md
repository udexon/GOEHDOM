# GOEHDOM



### Automated Maintenance of War Games

-- How may we automate the improvement of war games?

We believe this concise and well defined question encapsulates the roadmap towards achieving human level artificial intelligence.



### Automated Maintenance of Free Software Repositories as Measurement of Timeline Towards Technological Singularity (AMFSRTS, pronounced "AM-first")

We invite readers to consider the following scenario:

1. The number of programmers involved in improving code in GitHub or other free software repositories is huge.

2. The collective complexity of the code in the published free software repositories is beyond the comprehension of any single human programmer.

3. Despite the above, changes to any existing code repository are being done one line at a time.

4. What if we conceive a model to represent step 3?

5. If successful, step 4 would eventually increase the automation level improving code repositories.

6. We may measure the speed at which the automation grows and predict the point of technological singularity, where automation exceeds collective human effort.

We believe the above is a concise and well defined method to measure the timeline towards technological singularity, based on automation of improvement on free software repositories.


### Open Ended Homoiconic Document Model

https://github.com/udexon/Shumage/blob/master/OEHDOM_eng.md

https://github.com/udexon/Shumage/blob/master/Metaprogramming.md

https://github.com/udexon/Shumage/blob/master/README.md


### Goal Oriented Open Ended Homoiconic Document Model

Goal Oriented Open Ended Homoiconic Document Model (GOEHDOM) (think "Gotham city" in Batman)

War games provide us the goals for GOEHDOM (think "Gotham city" in Batman). 


### Goal Oriented Open Ended Homoiconic Document Model

-- A Goal oriented homoiconic model for artificial intelligence: Improving war games incrementally to achieve human level artificial intelligence



Of the many challenges facing artificial intelligence research, theorem proving and incremental construction of program code stand the best chance of  providing a tractable road map towards the final goal of human level artificial intelligence.

All programs have source code. All source code can be modified using Goal oriented OEHDOM (GOEHDOM).

Our model focuses on how the mechanisms  by which human programmers write programs. 

Prime motivation of DJ app is get more traffic, get more money.

Next level is cooking class.

Social evolution.

War games? 

How do we automate improvement of war games?

:: The above encapsulate the roadmap towards human level artificial intelligence. 
We do not need to start from scratch. We just need GOEHDOM.


Programmers have proven track record on WHAT to improve to make collective system more intelligent, but do not have an incremental homoiconic system to develop it. Emphasize "more intelligent", self explanatory and clearly defined, compared to "human level artificial intelligence". 


打造 Dijkstra、 Turing 级数的大师

突破 Stack Computer comp.lang.forth 老前辈 资源


Open Ended Homoiconic Document Model

在万能代码的基础上， 我们可以开发出一个 “无终结开放型文件模式”。 至今为止， 所有的计算机文件模式， 都是有始有终的。所谓  “无终结开放型文件模式”， 就是在原有的目录结构和文件里， 加入新弗式的指令， 可以代表程序员对现有文件的改动。

我们改动的文件， 主要是编程项目里调适及源码文件。 许多编程项目的文件， 其繁冗复杂程度， 例如安卓应用项目， 编程项目的文件， 早已发展到超越人手调置的限度。新的工具和程序语言被开发来处理现有的项目文件， 把总体结构和文件简化了吗？ 还是更加繁复？我们要 如何一劳永逸的解决这个问题？

新弗式差别码的原理， 来自程序员编辑源码文件的动作， 例如， 删、 插入、 移动、 抄、 粘帖等。 这些动作的指令， 还存在于历史悠久的 sed 及 vi 等工具。 GitHub patch file 也同属一类。 然而， 这些指令， 不能算得上是全面的程序语言。 不过， 它们和程序语言的差别， 其实只是一桥之隔。引用这个成语， 是暗喻图论祖师爷欧拉的七桥问题。 新弗式就可以统合文件编辑指令和全面程序语言。 

https://stackoverflow.com/questions/8279602/what-is-a-patch-in-git-version-control

我们分析一个相对复杂， 实在的项目， 来讲解新弗式的运用原理：

Vinyl Cast 和 Rhythm Game 是两个基于 Google Oboe ( 谷歌  双簧管  )  的安卓应用项目。  双簧管 是 安卓平台上的一个 C++ 高效能音频处理库， Vinyl Cast 原本的作用， 是在安卓仪器上录制胶盘的音乐， 然后以 http 协定， 转播到浏览器上。 Rhythm Game 是一个混合拍打和音乐的示范应用。  理论上， 我们可以改良以上的项目， 制作一个 DJ 混音的应用， 并加入 http 转播功能， 形成一种新式的 “接龙混音” 应用。

改动原有源码文件和调置文件的过程， 完全是程序员手动操作， 即使用文本编辑器， 改动原文件的字节。 

Metaprogramming 元编程， 是使用第三方工具或语言， 间接的对原始文件改动。

人们在讨论技术问题和方法时， 会牵涉到高阶或低阶的概念和实际操作。  程序员改动源码文件就是一个低阶的实际操作。 元编程， 是高阶的实际操作。 

一般的程序开发， 程序员很少会直接使用元编程。 

新弗式， 可以将元编程普及到所有已知的程序语言， 让程序员使用高阶的元编程， 对源码进行改动。

https://zh.m.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B


如维基百科 “元编程” 所述， 一般人对元编程的认识只局限于单一程序语言范围内应用， 而新弗式的跨语言元编程， 是一个突破性的新发明。 

新弗式， 可以对任何已知的程序语言进行元编程。 

元编程， 到底是什么高深莫测高大上的玩意儿？ 还是一种深入浅出、 返璞归真、 化整为零的玩意儿？ 

示范 

Program A: echo 1

Program B: echo 2

sed -i 's/old-text/new-text/g' input.txt

Why 1 and 2? 

What about this?

Program C: echo $1 

Or

If ... echo 1Else echo 2

Or just print for debug purposes? 

Based on this simple example, we may ask the questions above. These questions concerning metaprogramming are easily understood. However, there has been no single comprehensive programming language that can be used to address these questions. 

Easy to understand, lots of work to find solutions. 

问题浅显易懂， 答案高深莫测。 新弗式是解答的工具。 

其中一个最基本的问题， 就是如何用程序语言代表问题， 然后分析问题， 自动或半自动找出或运算出解方？ 新弗式皆可胜任。

Question answering is a niche area in AI. Not sure the programming languages used by others can address metaprogramming issues?

It is easy for human beings to conceive questions. It is non trivial for programmers to find programming languages or data structures to represent questions. 

Implement prolog in forth? 

Fundamentally,  we may need to simulate the motivations of a programmer -- why is he writing a program? To survive, of course. Then we may need to simulate food, energy and defense, how he develop sense of survival since birth. 

Goal based problems. Map. Path finding. Reverse kinematics etc. Generalized to all problems, including programming? Use Phos to prove. 

Theories or models similar to this might have been proposed elsewhere, however, our novelty is Phos, a homoiconic multi level programming language that can used to prove and implement such model step by step. 

Goal oriented homoiconic model for artificial intelligence

Most programming assignments (academic or commercial) have limited set of goals. The  Programmer's task is to find sets of combination of functions to map input to output, consistent with graph theory. 


   程序员手动编辑， 后生成 patch 。 程序员手动编辑的思绪及过程， 用新弗式表现出来。 





GitHub patch code is not full fledged programmable script. Phos is. 

Phos command can be embedded as comments in any existing file or additional files in existing directory or a new subdirectory. Call it Delta code.

Delta code is the basis of fees pay out. Conflict with free software licenses? Depends. Discuss several scenario.

Use Android project to illustrate. Gradle is based on groovy, a JVM derived Language. 





以下是本人制作的一个简单教程， 介绍由 Forth 延伸出来的 Phos “新弗式” 程序语言：

http://5gl.epizy.com/nsm/fgl.html?i=1

Phos 取自基督教圣经旧约 Genesis 1:3 “γενηθήτω φῶς (genēthētō phōs)” 希腊文小写 φῶς 大写 ΦΩ∑， 拉丁文 fiat lux， 英文 Let there be light， 意为 “光初现”。 Phos 与 Forth 谐音， 代表 Forth 的升级版， 故中译 “新弗式”。

新弗式主要的功能， 是以旧弗式为基础，改良为一套能通译各种程序语言的 “万能代码” 。

https://en.wikipedia.org/wiki/Let_there_be_light
我不是基督教徒， 引用圣经， 目的是 ”以夷制夷“， 让国人理解西方文明的根源与弊病。

万： 道生一 三生万物 
